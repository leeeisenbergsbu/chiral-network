<script lang="ts">
  import Card from '$lib/components/ui/card.svelte'
  import Button from '$lib/components/ui/button.svelte'
  import Badge from '$lib/components/ui/badge.svelte'
  import Progress from '$lib/components/ui/progress.svelte'
  import Input from '$lib/components/ui/input.svelte'
  import Label from '$lib/components/ui/label.svelte'
  import type { MiningHistoryPoint } from '$lib/stores';
  import { Cpu, Zap, TrendingUp, Award, Play, Pause, Coins, Thermometer, AlertCircle, Terminal, X, RefreshCw, Network } from 'lucide-svelte'
  import { onDestroy, onMount, getContext } from 'svelte'
  import { invoke } from '@tauri-apps/api/core'
  import { etcAccount, miningState } from '$lib/stores'
  import { getVersion } from "@tauri-apps/api/app";
  import { t } from 'svelte-i18n';
  import { goto } from '@mateothegreat/svelte5-router';
  import { walletService } from '$lib/wallet'; 
  
  // Local UI state only
  let isTauri = false
  let isGethRunning = false
  let currentBlock = 0
  let totalHashes = 0
  let lastHashUpdate = Date.now()
  let cpuThreads = navigator.hardwareConcurrency || 4
  let selectedThreads = Math.floor(cpuThreads / 2)
  let error = '' 

  // Network statistics
  let networkHashRate = '0 H/s'
  let networkDifficulty = '0'
  let blockReward = 2 // Chiral per block
  let peerCount = 0

  // Statistics - preserve across page navigation
  let sessionStartTime = $miningState.isMining ? 
    $miningState.sessionStartTime || Date.now() : 
    Date.now()
  let estimatedTimeToBlock = 0
  $: powerConsumption = $miningState.activeThreads * 15
  $: efficiency = $miningState.hashRate === '0 H/s' ? 0 : parseHashRate($miningState.hashRate) / powerConsumption
  let temperature = 0.0
  let hasRealTemperature = false
  let temperatureLoading = true // Add loading state for temperature checks
  let hasCompletedFirstCheck = false // Track if we've completed the first temperature check
  let temperatureUnit: 'C' | 'F' = 'C'

  // Uptime tick (forces template to re-render every second while mining)
  let uptimeNow: number = Date.now()
  let uptimeInterval: number | null = null
  
  // Mining history is now stored in the miningState store
  // let recentBlocks: RecentBlock[] = []
  
  // Mock mining intervals  
  let statsInterval: number | null = null
  
  // Logs
  let showLogs = false
  let logs: string[] = []
  let logsInterval: number | null = null
  // simplified log view — no font/wrap controls
  // Auto-refresh toggle for logs modal
  let autoRefresh: boolean = true
  // Wrap toggle for logs (true = wrap lines, false = preserve long lines with horizontal scroll)
  let wrapLogs: boolean = true

  // Log filtering
  let logFilters: { [key: string]: boolean } = {
    error: true,
    warn: true,
    info: true,
    other: true
  }

  // Computed filtered logs
  $: filteredLogs = logs.filter(log => {
    const level = detectLogLevel(log)
    return logFilters[level]
  })

  function parseDifficulty(difficultyStr: string): number {
    const match = difficultyStr.match(/^([\d.]+)\s*([KGMTP]?)H?\/?s?$/i)
    if (!match) return 0
    
    const value = parseFloat(match[1])
    const unit = match[2].toUpperCase()
    
    switch (unit) {
      case 'K': return value * 1000
      case 'M': return value * 1000000
      case 'G': return value * 1000000000
      case 'T': return value * 1000000000000
      case 'P': return value * 1000000000000000
      default: return value
    }
  }

  $: displayedTemperature = temperatureUnit === 'F' ? toFahrenheit(temperature).toFixed(1) : temperature.toFixed(1);

  function parseHashRate(rateStr: string): number {
    const match = rateStr.match(/^~?\s*([\d.]+)\s*([KMGT])H\/s$/i);
    
    // Fallback: If the regex fails (e.g., if the string is just "0 H/s"), return 0.
    if (!match) return 0;
    
    // Match indices: 1 is the value, 2 is the unit (K, M, G, T)
    const value = parseFloat(match[1]);
    const unit = match[2] ? match[2].toUpperCase() : ''; // Handle base H/s case if needed, though this regex forces a unit
    
    switch (unit) {
      case 'K': return value * 1000;
      case 'M': return value * 1000000;
      case 'G': return value * 1000000000;
      case 'T': return value * 1000000000000;
      default: return value; // Assumes base H/s if no unit is captured (e.g., if regex simplified)
    }
  }


  $: {
    const localHashRateNum = parseHashRate($miningState.hashRate);
    const networkDifficultyNum = parseDifficulty(networkDifficulty);
    
    if (localHashRateNum > 0 && networkDifficultyNum > 0) {
        // ETB = Difficulty / Hashrate (in seconds)
        estimatedTimeToBlock = networkDifficultyNum / localHashRateNum;
    } else {
        estimatedTimeToBlock = 0;
    }
  }



  // Function to convert Celsius to Fahrenheit
  function toFahrenheit(celsius: number): number {
    return (celsius * 9/5) + 32;
  }

  // Determine log level from a log line and return a semantic level
  function detectLogLevel(line: string): 'error' | 'warn' | 'info' | 'other' {
    if (!line) return 'other'
    const l = line.toLowerCase()
    if (l.includes('error') || l.includes('err') || l.includes('fatal')) return 'error'
    if (l.includes('warn') || l.includes('warning')) return 'warn'
    if (l.includes('info') || l.includes('[i]') || l.includes('notice')) return 'info'
    return 'other'
  }

  // Map level to Tailwind classes (text color + subtle opacity for less-important levels)
  function logLevelClass(line: string): string {
    const level = detectLogLevel(line)
    switch (level) {
      case 'error':
        return 'text-red-400'
      case 'warn':
        return 'text-amber-400'
      case 'info':
        return 'text-blue-300'
      default:
        return 'text-muted-foreground'
    }
  }

  // Parse a log line and extract a severity prefix (if present) and the rest of the message.
  // Example: "INFO [09-14|16:32:29.577] Message..." -> { prefix: 'INFO', rest: '[09-14|16:32:29.577] Message...' }
  function splitLogPrefix(line: string): { prefix: string | null; rest: string } {
    if (!line) return { prefix: null, rest: '' }
    // Match leading ALL-CAPS token (usually INFO, WARN, ERROR, DEBUG) optionally followed by a timestamp bracket
    const m = line.match(/^([A-Z]{3,7})\b\s*(.*)$/)
    if (m) {
      return { prefix: m[1], rest: m[2] }
    }
    return { prefix: null, rest: line }
  }



 // Bar or Line chart toggle
  let chartType: 'bar' | 'line' = 'bar';

  // Threads and intensity warnings
  let threadsWarning = '';
  let intensityWarning = '';

  let validationError: string | null = null;

  // Decentralized Pool Mining State
  interface MiningPool {
    id: string;
    name: string;
    url: string;
    description: string;
    fee_percentage: number;
    miners_count: number;
    total_hashrate: string;
    last_block_time: number;
    blocks_found_24h: number;
    region: string;
    status: 'Active' | 'Maintenance' | 'Full' | 'Offline';
    min_payout: number;
    payment_method: string;
    created_by?: string;
    worker?: string;
    password?: string;
    discovered_via_p2p?: boolean; // Added for P2P pool discovery tracking
  }

  interface PoolStats {
    connected_miners: number;
    pool_hashrate: string;
    your_hashrate: string;
    your_share_percentage: number;
    shares_submitted: number;
    shares_accepted: number;
    estimated_payout_24h: number;
    last_share_time: number;
  }

  interface JoinedPoolInfo {
    pool: MiningPool;
    stats: PoolStats;
    joined_at: number;
  }

  interface ShareSubmission {
    pool_id: string;
    miner_address: string;
    nonce: string;
    hash: string;
    difficulty: number;
    timestamp: number;
  }

  // Pool state
  let availablePools: MiningPool[] = [];
  let currentPool: JoinedPoolInfo | null = null;
  let poolError: string = '';
  let isDiscovering: boolean = false;
  let showCreatePool: boolean = false;
  let showPoolList: boolean = false;
  let editingPool: MiningPool | null = null;
  let showPoolManager: boolean = false;
  let poolConnected: boolean = false;
  let poolStats = {
    connectedMiners: 0,
    poolHashrate: '0 H/s',
    yourHashrate: '0 H/s',
    yourSharePercentage: 0,
    sharesSubmitted: 0,
    sharesAccepted: 0,
    estimatedPayout24h: 0,
    lastShareTime: 0
  };
  
  // Pool creation form
  let newPool = {
    name: '',
    description: '',
    fee_percentage: 1.0,
    min_payout: 1.0,
    payment_method: 'PPLNS',
    region: 'Global',
    url: '',
    worker: '',
    password: ''
  };

  // Computed values
  $: poolConnected = currentPool !== null;
  $: if (currentPool) {
    poolStats = {
      connectedMiners: currentPool.stats.connected_miners,
      poolHashrate: currentPool.stats.pool_hashrate,
      yourHashrate: currentPool.stats.your_hashrate,
      yourSharePercentage: currentPool.stats.your_share_percentage,
      sharesSubmitted: currentPool.stats.shares_submitted,
      sharesAccepted: currentPool.stats.shares_accepted,
      estimatedPayout24h: currentPool.stats.estimated_payout_24h,
      lastShareTime: currentPool.stats.last_share_time
    };
  }

  const navigation = getContext('navigation') as { setCurrentPage: (page: string) => void };
  
  // Computed values for threads based on intensity
  const maxThreads = cpuThreads
  // Intensity slider directly controls selectedThreads
  $: if (!$miningState.isMining) {
    selectedThreads = Math.ceil(($miningState.minerIntensity / 100) * maxThreads)
  }


  // Threads warning
  $: {
    const numThreads = Number(selectedThreads);
    threadsWarning = (numThreads < 1 || numThreads > cpuThreads)
            ? $t('mining.errors.threads', { values: { cpuThreads } })
            : '';
  }

  // Intensity warning
  $: {
    const numIntensity = Number($miningState.minerIntensity);
    intensityWarning = (numIntensity < 1 || numIntensity > 100)
            ? $t('mining.errors.intensity')
            : '';
  }

  $: if (!$etcAccount) {
    // Clear mining state when no account is present
    if ($miningState.isMining) {
      stopMining(); // Stop mining if running
    }
    // Reset mining display state
    $miningState.totalRewards = 0;
    $miningState.blocksFound = 0;
    $miningState.recentBlocks = [];
  }

  // Button disabled if either warning exists
  $: isInvalid = !!threadsWarning || !!intensityWarning;


  let hoveredPoint: MiningHistoryPoint | null = null;
  let hoveredIndex: number | null = null;

  onMount(async () => {
    try{
      getVersion()
      isTauri = true
    }
    catch{
      isTauri = false
    }

    await checkGethStatus()
    await updateNetworkStats()
    // If mining is already active from before, restore session and update stats
    if ($miningState.isMining) {
      // Restore session start time if it exists
      if ($miningState.sessionStartTime) {
        sessionStartTime = $miningState.sessionStartTime
      }
      startUptimeTimer()
      await updateMiningStats()
    }
    if (isTauri) {
      await updateCpuTemperature()
    }
    
    // Initialize pool state
    try {
      const poolInfo = await invoke('get_current_pool_info') as JoinedPoolInfo | null;
      if (poolInfo) {
        currentPool = poolInfo;
        startPoolStatsUpdates();
      }
    } catch (e) {
      console.error('Failed to get current pool info:', e);
    }
    
    // Start polling for mining stats
    statsInterval = setInterval(async () => {
      if ($miningState.isMining) {
        // Update mining stats in parallel with wallet data
        await Promise.all([
          updateMiningStats(),
          // IMPORTANT: refreshTransactions must run BEFORE refreshBalance
          // because refreshBalance depends on blocksFound set by refreshTransactions
          (async () => {
            await walletService.refreshTransactions();
            await walletService.refreshBalance();
          })()
        ]);
      }
      await updateNetworkStats();
      if (isTauri) {
        await updateCpuTemperature();
      }
    }, 1000) as unknown as number;

    // Expose pool functions to window for debugging/testing
    // Always expose these functions, regardless of Tauri environment
    try {
      console.log('🔧 Setting up window.poolDebug...');
      (window as any).poolDebug = {
        // Legacy functions
        discoverPools,
        submitShare,
        calculatePayout,
        updatePoolHashrate,
        queryDHTForPools,
        announcePoolToDHT,
        getDetailedPoolStats,
        
        // P2P functions (prefixed)
        p2pAnnouncePool,
        p2pDiscoverPools,
        p2pSubmitShare,
        p2pGetPoolShares,
        p2pBecomeCoordinator,
        p2pFindCoordinator,
        p2pIsCoordinator,
        p2pResignCoordinator,
        
        // Convenient aliases for testing
        announcePool: p2pAnnouncePool,
        discoverPoolsP2P: p2pDiscoverPools,
        submitShareP2P: p2pSubmitShare,
        getPoolShares: p2pGetPoolShares,
        becomeCoordinator: p2pBecomeCoordinator,
        findCoordinator: p2pFindCoordinator,
        isCoordinator: p2pIsCoordinator,
        resignCoordinator: p2pResignCoordinator,
        
        // DHT helper functions
        getPeerId: async () => await invoke('get_dht_peer_id'),
        getPeerCount: async () => await invoke('get_dht_peer_count'),
        getConnectedPeers: async () => await invoke('get_dht_connected_peers'),
        
        // Tauri invoke (for advanced users)
        invoke: invoke,
      };
      console.log('✅ Pool debug functions available at window.poolDebug');
      console.log('💡 Use: window.poolDebug.announcePool(pool)');
      console.log('💡 DHT helpers: getPeerId(), getPeerCount(), getConnectedPeers()');
      console.log('💡 Available functions:', Object.keys((window as any).poolDebug).join(', '));
    } catch (error) {
      console.error('❌ Failed to set up window.poolDebug:', error);
    }
  })  
  
  async function checkGethStatus() {
    try {
      isGethRunning = await invoke('is_geth_running') as boolean
      if (isGethRunning) {
        // Only check backend status if we don't have a mining state already
        // This prevents losing state when switching pages
        if (!$miningState.isMining) {
          const status = await invoke('get_miner_status') as boolean
          if (status) {
            $miningState.isMining = status
            sessionStartTime = Date.now()
            startUptimeTimer()
          }
        } else {
          // If we already think we're mining, just restart the uptime timer
          startUptimeTimer()
        }
      }
    } catch (e) {
      console.error('Failed to check geth status:', e)
    }
  }
  
  async function updateMiningStats() {
    try {
      const [rate, block] = await Promise.all([
        invoke('get_miner_hashrate') as Promise<string>,
        invoke('get_current_block') as Promise<number>
      ])
      
      currentBlock = block
      
      // Try to get real hash rate from logs if standard API returns 0
      if (rate === '0 H/s' && $miningState.isMining) {
        try {
          // Get mining performance from logs
          const [blocksFound, hashRateFromLogs] = await invoke('get_miner_performance', { 
            dataDir: './bin/geth-data' 
          }) as [number, number]
          
          if (hashRateFromLogs > 0) {
            // Use actual hash rate from logs
            $miningState.hashRate = formatHashRate(hashRateFromLogs)
            $miningState.blocksFound = blocksFound;
          
            
          } else if ($miningState.activeThreads > 0) {
            // Fall back to simulation if no log data yet
            const elapsed = (Date.now() - sessionStartTime) / 1000 // seconds
            const baseRate = $miningState.activeThreads * 85000 // 85 KH/s per thread
            const variation = Math.sin(elapsed / 10) * baseRate * 0.1 // ±10% variation
            const simulatedRate = baseRate + variation
            $miningState.hashRate = `~${formatHashRate(simulatedRate)}`
          }
        } catch (perfError) {
          // If performance fetch fails, fall back to simulation
          if ($miningState.activeThreads > 0) {
            const elapsed = (Date.now() - sessionStartTime) / 1000
            const baseRate = $miningState.activeThreads * 85000
            const variation = Math.sin(elapsed / 10) * baseRate * 0.1
            const simulatedRate = baseRate + variation
            $miningState.hashRate = `~${formatHashRate(simulatedRate)}`
          }
        }
      } else if (rate !== '0 H/s') {
        // Use actual rate if available from standard API
        $miningState.hashRate = rate
      }
      
      // Convert hashRate string to number for chart
      let hashRateNum = 0
      // Clean up the rate string (remove ~ and text in parentheses)
      hashRateNum = parseHashRate($miningState.hashRate)
      
      // Update mining history for chart
      if ($miningState.isMining) {
        $miningState.miningHistory = [...($miningState.miningHistory || []).slice(-29), {
          timestamp: Date.now(),
          hashRate: hashRateNum,
          power: powerConsumption
        }]
        
        // Update total hashes based on hashrate and time elapsed
        const timeDelta = (Date.now() - lastHashUpdate) / 1000 // seconds
        totalHashes += Math.floor(hashRateNum * timeDelta)
        lastHashUpdate = Date.now()
      }
    } catch (e) {
      console.error('Failed to update mining stats:', e)
    }
  }
  
  
  async function updateNetworkStats() {
  try {
    if (isGethRunning) {
      const promises: Promise<any>[] = [
        invoke('get_network_stats') as Promise<[string, string]>,
        invoke('get_current_block') as Promise<number>,
        invoke('get_network_peer_count') as Promise<number>
      ]
      
      // Also fetch account balance and blocks mined if we have an account and are mining
      if ($etcAccount && $miningState.isMining) {
          promises.push(invoke('get_blocks_mined', { 
            address: $etcAccount.address 
          }) as Promise<number>)
      }
      
      const results = await Promise.all(promises)
      
      networkDifficulty = results[0][0]
      networkHashRate = results[0][1]
      currentBlock = results[1]
      peerCount = results[2]
      
      
       
              
      // Update blocks mined from blockchain query
      
      
    }
  } catch (e) {
    console.error('Failed to update network stats:', e)
  }
}

  async function updateCpuTemperature() {
    // Only show loading state for the very first check
    if (!hasCompletedFirstCheck) {
      temperatureLoading = true
    }
    
    try {
      const temp = await invoke('get_cpu_temperature') as number
      if (temp && temp > 0) {
        temperature = temp
        hasRealTemperature = true
      } else {
        hasRealTemperature = false
      }
    } catch (e) {
      console.error('Failed to get CPU temperature:', e)
      hasRealTemperature = false
    } finally {
      if (!hasCompletedFirstCheck) {
        temperatureLoading = false
        hasCompletedFirstCheck = true
      }
    }
  }
  
  function startUptimeTimer() {
    uptimeNow = Date.now()
    if (!uptimeInterval) {
      uptimeInterval = setInterval(() => {
        uptimeNow = Date.now()
      }, 1000) as unknown as number
    }
  }
  
  async function startMining() {
    if (!$etcAccount) {
      error = $t('mining.errors.noAccount')
      return
    }
    
    if (!isGethRunning) {
      error = $t('mining.errors.gethNotRunning')
      return
    }
    
    error = ''
    validationError = null
    
    try {
      // Show message that we're starting mining
      error = $t('mining.starting')
      
      await invoke('start_miner', {
        address: $etcAccount.address,
        threads: selectedThreads,
        dataDir: './bin/geth-data'
      })
      
      error = '' // Clear the status message
      $miningState.isMining = true
      sessionStartTime = Date.now()
      // Store session start time in the store for persistence
      $miningState.sessionStartTime = sessionStartTime
      $miningState.activeThreads = selectedThreads  // Use selectedThreads
      totalHashes = 0 // Reset total hashes
      lastHashUpdate = Date.now()
      startUptimeTimer() 

      // Start updating stats
      await updateMiningStats()
      
      // Update power consumption estimates
      powerConsumption = $miningState.activeThreads * 25 * ($miningState.minerIntensity / 100)
      
      // Re-check geth status since it might have restarted
      isGethRunning = true
    } catch (e) {
      error = String(e)
      console.error('Failed to start mining:', e)
    }
  }
  
  async function stopMining() {
    try {
      await invoke('stop_miner')
      $miningState.isMining = false
      $miningState.hashRate = '0 H/s'
      $miningState.activeThreads = 0 

      // Clear session start time
      $miningState.sessionStartTime = undefined
      // Clear mining history when stopping
      $miningState.miningHistory = []
      
      // stop uptime ticker
      if (uptimeInterval) {
        clearInterval(uptimeInterval as unknown as number)
        uptimeInterval = null
      }
    } catch (e) {
      error = String(e)
      console.error('Failed to stop mining:', e)
    }
  }

  // Decentralized Pool Functions
  async function discoverPools() {
    if (!$etcAccount) {
      poolError = 'Please create or import an account first.';
      return;
    }
    
    isDiscovering = true;
    poolError = '';
    
    try {
      console.log('🔍 Invoking discover_mining_pools command...');
      const pools = await invoke('discover_mining_pools') as MiningPool[];
      console.log('✅ Received pools:', pools);
      availablePools = pools;
      showPoolList = true;
      await invoke('update_pool_discovery'); // Update pool stats
    } catch (e) {
      console.error('❌ Pool discovery error:', e);
      poolError = String(e);
    } finally {
      isDiscovering = false;
    }
  }

  async function joinPool(pool: MiningPool) {
    if (!$etcAccount) {
      poolError = 'Please create or import an account first.';
      return;
    }
    
    if (pool.status === 'Offline') {
      poolError = 'Cannot join offline pool.';
      return;
    }
    
    poolError = '';
    
    try {
      const joinedInfo = await invoke('join_mining_pool', { 
        poolId: pool.id, 
        address: $etcAccount.address 
      }) as JoinedPoolInfo;
      
      currentPool = joinedInfo;
      showPoolList = false;
      
      // Start periodic stats updates
      startPoolStatsUpdates();
    } catch (e) {
      poolError = String(e);
    }
  }

  async function leavePool() {
    if (!currentPool) return;
    
    try {
      await invoke('leave_mining_pool');
      currentPool = null;
      stopPoolStatsUpdates();
    } catch (e) {
      poolError = String(e);
    }
  }

  async function createNewPool() {
    if (!$etcAccount) {
      poolError = 'Please create or import an account first.';
      return;
    }
    
    if (!newPool.name.trim()) {
      poolError = 'Pool name is required.';
      return;
    }
    
    poolError = '';
    
    try {
      const createdPool = await invoke('create_mining_pool', {
        address: $etcAccount.address,
        name: newPool.name,
        description: newPool.description,
        feePercentage: newPool.fee_percentage,
        minPayout: newPool.min_payout,
        paymentMethod: newPool.payment_method,
        region: newPool.region,
      }) as MiningPool;
      
      // Reset form
      newPool = {
        name: '',
        description: '',
        fee_percentage: 1.0,
        min_payout: 1.0,
        payment_method: 'PPLNS',
        region: 'Global',
        url: '',
        worker: '',
        password: ''
      };
      
      showCreatePool = false;
      
      // Announce pool to P2P network (DHT)
      try {
        await p2pAnnouncePool(createdPool);
        console.log('✅ Pool announced to P2P network');
      } catch (e) {
        console.warn('⚠️ Failed to announce pool to P2P network:', e);
        // Don't fail the entire operation if P2P announcement fails
      }
      
      // Automatically join the created pool
      await joinPool(createdPool);
    } catch (e) {
      poolError = String(e);
    }
  }

  // Pool stats updates
  let poolStatsInterval: number | null = null;
  let p2pShareSyncInterval: number | null = null;
  
  function startPoolStatsUpdates() {
    if (poolStatsInterval) return;
    
    poolStatsInterval = setInterval(async () => {
      if (!currentPool) {
        stopPoolStatsUpdates();
        return;
      }
      
      try {
        const stats = await invoke('get_pool_stats') as PoolStats;
        if (stats && currentPool) {
          currentPool.stats = stats;
          currentPool = { ...currentPool }; // Trigger reactivity
        }
      } catch (e) {
        console.error('Failed to update pool stats:', e);
      }
    }, 5000) as unknown as number; // Update every 5 seconds
    
    // If pool was discovered via P2P, sync shares from network
    if (currentPool?.pool?.discovered_via_p2p && !p2pShareSyncInterval) {
      console.log('🔄 Starting P2P share sync for pool:', currentPool.pool.id);
      p2pShareSyncInterval = setInterval(async () => {
        if (!currentPool?.pool?.id) return;
        
        try {
          // Get recent shares from P2P network (last hour)
          const since = Math.floor(Date.now() / 1000) - 3600;
          const shares = await p2pGetPoolShares(currentPool.pool.id, since);
          if (shares.length > 0) {
            console.log(`🔄 Synced ${shares.length} shares from P2P network`);
          }
        } catch (e) {
          console.error('Failed to sync P2P shares:', e);
        }
      }, 30000) as unknown as number; // Sync every 30 seconds
    }
  }
  
  function stopPoolStatsUpdates() {
    if (poolStatsInterval) {
      clearInterval(poolStatsInterval);
      poolStatsInterval = null;
    }
    if (p2pShareSyncInterval) {
      clearInterval(p2pShareSyncInterval);
      p2pShareSyncInterval = null;
    }
  }

  // ============================================================================
  // ENHANCED POOL FEATURES - DHT Integration
  // ============================================================================

  async function submitShare(nonce: number, hash: string, difficulty: number) {
    if (!$etcAccount || !currentPool) return;
    
    try {
      const accepted = await invoke('submit_mining_share', {
        minerAddress: $etcAccount.address,
        nonce,
        hash,
        difficulty
      });
      
      if (accepted) {
        console.log('✅ Share accepted by pool');
      } else {
        console.log('❌ Share rejected by pool');
      }
    } catch (e) {
      console.error('Failed to submit share:', e);
    }
  }

  async function calculatePayout() {
    if (!$etcAccount || !currentPool) return;
    
    try {
      let payout = 0;
      
      if (currentPool.pool.payment_method === 'PPLNS') {
        payout = await invoke('calculate_pplns_payout', {
          minerAddress: $etcAccount.address,
          blockReward: 2.0,
          nShares: 100
        }) as number;
      } else if (currentPool.pool.payment_method === 'PPS') {
        payout = await invoke('calculate_pps_payout', {
          minerAddress: $etcAccount.address,
          blockReward: 2.0
        }) as number;
      }
      
      console.log(`💰 Estimated payout: ${payout} Chiral`);
      return payout;
    } catch (e) {
      console.error('Failed to calculate payout:', e);
      return 0;
    }
  }

  async function updatePoolHashrate() {
    if (!$etcAccount || !currentPool) return;
    
    try {
      const hashRateNum = parseHashRate($miningState.hashRate);
      await invoke('update_pool_hashrate', {
        minerAddress: $etcAccount.address,
        hashrate: hashRateNum
      });
    } catch (e) {
      console.error('Failed to update pool hashrate:', e);
    }
  }

  async function queryDHTForPools(regionFilter?: string) {
    isDiscovering = true;
    poolError = '';
    
    try {
      console.log('🔍 Querying DHT for pools...');
      const pools = await invoke('query_dht_for_pools', {
        regionFilter
      }) as MiningPool[];
      
      console.log('✅ Found pools via DHT:', pools.length);
      availablePools = pools;
      showPoolList = true;
    } catch (e) {
      console.error('❌ DHT query error:', e);
      poolError = String(e);
    } finally {
      isDiscovering = false;
    }
  }

  async function announcePoolToDHT(pool: MiningPool) {
    try {
      await invoke('announce_pool_to_dht', { pool });
      console.log('✅ Pool announced to DHT network');
    } catch (e) {
      console.error('Failed to announce pool:', e);
      poolError = String(e);
    }
  }

  async function getDetailedPoolStats(poolId: string) {
    try {
      const stats = await invoke('get_detailed_pool_stats', {
        poolId
      }) as Record<string, any>;
      
      console.log('📊 Detailed pool stats:', stats);
      return stats;
    } catch (e) {
      console.error('Failed to get detailed stats:', e);
      return null;
    }
  }

  // Enhanced pool discovery with DHT
  async function discoverPoolsEnhanced() {
    if (!$etcAccount) {
      poolError = 'Please create or import an account first.';
      return;
    }
    
    isDiscovering = true;
    poolError = '';
    
    try {
      // Query both local cache and DHT network
      const [localPools, dhtPools] = await Promise.all([
        invoke('discover_mining_pools') as Promise<MiningPool[]>,
        invoke('query_dht_for_pools', {}) as Promise<MiningPool[]>
      ]);
      
      // Merge and deduplicate pools
      const poolMap = new Map<string, MiningPool>();
      [...localPools, ...dhtPools].forEach(pool => {
        poolMap.set(pool.id, pool);
      });
      
      availablePools = Array.from(poolMap.values());
      console.log('✅ Discovered pools:', availablePools.length);
      showPoolList = true;
    } catch (e) {
      console.error('❌ Enhanced pool discovery error:', e);
      poolError = String(e);
    } finally {
      isDiscovering = false;
    }
  }

  function getPoolStatusColor(status: string): string {
    switch (status) {
      case 'Active': return 'text-green-500';
      case 'Maintenance': return 'text-yellow-500';
      case 'Full': return 'text-orange-500';
      case 'Offline': return 'text-red-500';
      default: return 'text-gray-500';
    }
  }

  function formatTimestamp(timestamp: number): string {
    const now = Date.now() / 1000;
    const diff = now - timestamp;
    
    if (diff < 60) return `${Math.floor(diff)}s ago`;
    if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
    if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
    return `${Math.floor(diff / 86400)}d ago`;
  }

  // Pool management functions
  function editPool(pool: MiningPool) {
    editingPool = { ...pool };
    showPoolManager = true;
  }

  function cancelPoolEdit() {
    editingPool = null;
    showPoolManager = false;
  }

  function deletePool(poolId: string) {
    // Remove pool from available pools
    availablePools = availablePools.filter(p => p.id !== poolId);
    
    // If this was the current pool, leave it
    if (currentPool && currentPool.pool.id === poolId) {
      leavePool();
    }
  }

  // Save changes to an existing pool (edit functionality)
  function savePool() {
    if (!editingPool) return;
    
    // Store the editing pool in a local variable to satisfy TypeScript
    const poolToEdit = editingPool;
    
    // Find and update the pool in availablePools
    availablePools = availablePools.map(pool =>
      pool.id === poolToEdit.id
        ? {
            ...pool,
            ...poolToEdit,
            id: poolToEdit.id ?? pool.id, // Ensure id is always a string
            name: poolToEdit.name ?? pool.name,
            url: poolToEdit.url ?? pool.url,
            description: poolToEdit.description ?? pool.description,
            fee_percentage: poolToEdit.fee_percentage ?? pool.fee_percentage,
            miners_count: poolToEdit.miners_count ?? pool.miners_count,
            total_hashrate: poolToEdit.total_hashrate ?? pool.total_hashrate,
            last_block_time: poolToEdit.last_block_time ?? pool.last_block_time,
            blocks_found_24h: poolToEdit.blocks_found_24h ?? pool.blocks_found_24h,
            region: poolToEdit.region ?? pool.region,
            status: poolToEdit.status ?? pool.status,
            min_payout: poolToEdit.min_payout ?? pool.min_payout,
            payment_method: poolToEdit.payment_method ?? pool.payment_method,
            created_by: poolToEdit.created_by ?? pool.created_by,
            worker: poolToEdit.worker ?? pool.worker ?? '',
            password: poolToEdit.password ?? pool.password ?? ''
          }
        : pool
    );
    editingPool = null;
    showPoolManager = false;
  }

  // Add a new pool (for modal form)
  function addPool() {
    // Basic validation
    if (!newPool.name.trim()) return;
    // Generate a unique id for the new pool
    const id = `pool-${Date.now()}`;
    availablePools = [
      ...availablePools,
      {
        ...newPool,
        id,
        status: 'Active',
        miners_count: 1,
        total_hashrate: '0 H/s',
        last_block_time: 0,
        blocks_found_24h: 0,
        created_by: $etcAccount ? $etcAccount.address : '',
      }
    ];
    // Reset form and close modal
    newPool = {
      name: '',
      description: '',
      fee_percentage: 1.0,
      min_payout: 1.0,
      payment_method: 'PPLNS',
      region: 'Global',
      url: '',
      worker: '',
      password: ''
    };
    showPoolManager = false;
  }

  // ============================================================================
  // P2P POOL FUNCTIONS - Real peer-to-peer pool integration with DHT
  // ============================================================================

  // Announce a pool to the P2P network via DHT
  async function p2pAnnouncePool(pool: MiningPool) {
    try {
      await invoke('p2p_announce_pool', { pool });
      console.log('✅ Pool announced to P2P network:', pool.id);
      return true;
    } catch (e) {
      console.error('❌ Failed to announce pool:', e);
      poolError = String(e);
      return false;
    }
  }

  // Discover pools from P2P network
  async function p2pDiscoverPools(poolId?: string) {
    isDiscovering = true;
    poolError = '';
    
    try {
      const pools = await invoke('p2p_discover_pools', { 
        poolId: poolId || null 
      }) as MiningPool[];
      
      // Mark pools as P2P-discovered
      const p2pPools = pools.map(pool => ({
        ...pool,
        discovered_via_p2p: true
      }));
      
      console.log('✅ Discovered P2P pools:', p2pPools.length);
      availablePools = p2pPools;
      showPoolList = true;
      return p2pPools;
    } catch (e) {
      console.error('❌ Failed to discover P2P pools:', e);
      poolError = String(e);
      return [];
    } finally {
      isDiscovering = false;
    }
  }

  // Submit a mining share to the P2P pool
  async function p2pSubmitShare(share: ShareSubmission): Promise<boolean> {
    try {
      await invoke('p2p_submit_share', { share });
      console.log('✅ Share submitted to P2P pool');
      return true;
    } catch (e) {
      console.error('❌ Failed to submit share:', e);
      return false;
    }
  }

  // Get shares for a pool from P2P network
  async function p2pGetPoolShares(poolId: string, since?: number): Promise<ShareSubmission[]> {
    try {
      const shares = await invoke('p2p_get_shares_for_pool', {
        poolId,
        since: since || null
      }) as ShareSubmission[];
      console.log('✅ Retrieved pool shares:', shares);
      return shares;
    } catch (e) {
      console.error('❌ Failed to get pool shares:', e);
      return [];
    }
  }

  // Become a pool coordinator
  async function p2pBecomeCoordinator(poolId: string): Promise<boolean> {
    try {
      const success = await invoke('p2p_become_coordinator', { poolId }) as boolean;
      if (success) {
        console.log('✅ Became pool coordinator for:', poolId);
      }
      return success;
    } catch (e) {
      console.error('❌ Failed to become coordinator:', e);
      return false;
    }
  }

  // Find the coordinator for a pool
  async function p2pFindCoordinator(poolId: string): Promise<string | null> {
    try {
      const coordinator = await invoke('p2p_find_coordinator', { poolId }) as string | null;
      console.log('✅ Pool coordinator:', coordinator || 'None');
      return coordinator;
    } catch (e) {
      console.error('❌ Failed to find coordinator:', e);
      return null;
    }
  }

  // Check if we are a coordinator
  async function p2pIsCoordinator(): Promise<boolean> {
    try {
      const isCoord = await invoke('p2p_is_coordinator') as boolean;
      return isCoord;
    } catch (e) {
      console.error('❌ Failed to check coordinator status:', e);
      return false;
    }
  }

  // Resign from coordinator role
  async function p2pResignCoordinator(): Promise<boolean> {
    try {
      await invoke('p2p_resign_coordinator');
      console.log('✅ Resigned from coordinator role');
      return true;
    } catch (e) {
      console.error('❌ Failed to resign as coordinator:', e);
      return false;
    }
  }

  // Define pools variable as an alias for availablePools for compatibility
  $: pools = availablePools;

  // Pagination for recent blocks
  let pageSizes = [5, 10, 20, 50]
  let pageSize: number = 10
  let currentPage: number = 1

  // Derived values
  $: totalBlocks = ($miningState.recentBlocks || []).length
  $: totalPages = Math.max(1, Math.ceil(totalBlocks / pageSize))
  $: {
    // Clamp currentPage when totalPages or pageSize changes
    if (currentPage > totalPages) currentPage = totalPages
    if (currentPage < 1) currentPage = 1
  }

  // When recentBlocks array changes (new block added or removed) we rely on
  // pushRecentBlock to set currentPage = 1 so the newest block is visible.

  $: displayedBlocks = ($miningState.recentBlocks || []).slice((currentPage - 1) * pageSize, currentPage * pageSize)
  
  function formatUptime(now: number = Date.now()) {
    const uptime = now - sessionStartTime
    const hours = Math.floor(uptime / 3600000)
    const minutes = Math.floor((uptime % 3600000) / 60000)
    const seconds = Math.floor((uptime % 60000) / 1000)
    return `${hours}h ${minutes}m ${seconds}s`
  }

  function formatTimeFromSeconds(totalSeconds: number): string {
      if (totalSeconds < 60) {
          return `${totalSeconds.toFixed(0)}s`;
      }

      const seconds = Math.floor(totalSeconds);
      const hours = Math.floor(seconds / 3600);
      const minutes = Math.floor((seconds % 3600) / 60);
      const remainingSeconds = seconds % 60;

      let parts = [];
      if (hours > 0) {
          parts.push(`${hours}h`);
      }
      if (minutes > 0) {
          parts.push(`${minutes}m`);
      }
      // Only show seconds if the total time is less than an hour, or if minutes is 0
      if (hours === 0 && minutes < 5) { // Show seconds when time is short
          parts.push(`${remainingSeconds}s`);
      }

      return parts.join(' ');
  }

  function formatHashRate(rate: number | string): string {
    if (typeof rate === 'string') return rate
    if (rate < 1000) return `${rate.toFixed(1)} H/s`
    if (rate < 1000000) return `${(rate / 1000).toFixed(2)} KH/s`
    if (rate < 1000000000) return `${(rate / 1000000).toFixed(2)} MH/s`
    return `${(rate / 1000000000).toFixed(2)} GH/s`
  }
  
  function formatNumber(num: number): string {
    if (num < 1000) return num.toString()
    if (num < 1000000) return `${(num / 1000).toFixed(1)}K`
    if (num < 1000000000) return `${(num / 1000000).toFixed(1)}M`
    return `${(num / 1000000000).toFixed(1)}B`
  }
  
  async function fetchLogs() {
    try {
      const result = await invoke('get_miner_logs', {
        dataDir: './bin/geth-data',
        lines: 100
      }) as string[]
      logs = result
    } catch (e) {
      console.error('Failed to fetch logs:', e)
    }
  }
  
  function toggleLogs() {
    showLogs = !showLogs
    if (showLogs) {
      fetchLogs()
      // Start auto-refresh of logs if enabled
      if (autoRefresh) {
        logsInterval = setInterval(fetchLogs, 2000) as unknown as number
      }
    } else {
      // Stop auto-refresh
      if (logsInterval) {
        clearInterval(logsInterval)
        logsInterval = null
      }
    }
  }
  // Remove old pool management code - replaced with decentralized system
  
  onDestroy(async () => {
    // Don't stop mining when leaving the page - preserve state
    // Only clean up intervals
    if (statsInterval) {
      clearInterval(statsInterval)
    }
    if (uptimeInterval) {
      clearInterval(uptimeInterval)
    }
    if (logsInterval) {
      clearInterval(logsInterval)
    }
    if (poolStatsInterval) {
      clearInterval(poolStatsInterval)
    }
  })

</script>

<div class="space-y-6">
  <div>
    <h1 class="text-3xl font-bold">{$t('mining.title')}</h1>
    <p class="text-muted-foreground mt-2">{$t('mining.subtitle')}</p>
  </div>
  
  <!-- Mining Status Cards -->
  <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
    <Card class="p-4">
      <div class="flex items-center justify-between">
        <div>
          <p class="text-sm text-muted-foreground">{$t('mining.hashRate')}</p>
          <p class="text-2xl font-bold">{$miningState.hashRate}</p>
          <p class="text-xs text-muted-foreground mt-1">
            {$miningState.isMining ? `${$miningState.activeThreads} ${$t('mining.threads')}` : $t('mining.notMining')}
          </p>
        </div>
        <div class="p-2 bg-primary/10 rounded-lg">
          <Cpu class="h-5 w-5 text-primary" />
        </div>
      </div>
    </Card>
    
    <Card class="p-4">
      <div class="flex items-center justify-between">
        <div>
          <p class="text-sm text-muted-foreground">{$t('mining.totalRewards')}</p>
          <p class="text-2xl font-bold">{($miningState.totalRewards || 0).toFixed(2)} Chiral</p>
          <p class="text-xs text-green-600 flex items-center gap-1 mt-1">
            <TrendingUp class="h-3 w-3" />
            {$miningState.blocksFound} {$t('mining.blocksFound')}
          </p>
        </div>
        <div class="p-2 bg-yellow-500/10 rounded-lg">
          <Coins class="h-5 w-5 text-yellow-500" />
        </div>
      </div>
    </Card>
    
    <Card class="p-4">
      <div class="flex items-center justify-between">
        <div>
          <p class="text-sm text-muted-foreground">{$t('mining.powerUsage')}</p>
          <p class="text-2xl font-bold">{powerConsumption.toFixed(0)}W</p>
          <p class="text-xs text-muted-foreground mt-1">
            {efficiency.toFixed(2)} {$t('mining.hw')}
          </p>
        </div>
        <div class="p-2 bg-amber-500/10 rounded-lg">
          <Zap class="h-5 w-5 text-amber-500" />
        </div>
      </div>
    </Card>
    
    <Card class="p-4">
      <div class="flex items-center justify-between">
        <div>
          <p class="text-sm text-muted-foreground">{$t('mining.temperature')}</p>
          {#if temperatureLoading}
            <p class="text-2xl font-bold text-blue-500">--°C</p>
          {:else if hasRealTemperature}
            <p class="text-2xl font-bold {temperature > 80 ? 'text-red-500' : temperature > 70 ? 'text-orange-500' : temperature > 60 ? 'text-yellow-500' : 'text-green-500'}">{displayedTemperature}°{temperatureUnit}</p>
          {:else}
            <p class="text-2xl font-bold text-gray-500">N/A</p>
          {/if}
          <div class="mt-1">
            {#if temperatureLoading}
              <p class="text-xs text-muted-foreground mt-1">Detecting temperature sensors...</p>
            {:else if hasRealTemperature}
              <Progress 
                value={Math.min(temperature, 100)} 
                max={100} 
                class="h-2 {temperature > 80 ? '[&>div]:bg-red-500' : temperature > 70 ? '[&>div]:bg-orange-500' : temperature > 60 ? '[&>div]:bg-yellow-500' : '[&>div]:bg-green-500'}"
              />
              <p class="text-xs text-muted-foreground mt-1">
                {temperature > 85 ? $t('mining.temperatureStatus.critical') : temperature > 75 ? $t('mining.temperatureStatus.hot') : temperature > 65 ? $t('mining.temperatureStatus.warm') : $t('mining.temperatureStatus.normal')}
              </p>
            {:else}
              <Progress value={0} max={100} class="h-2 opacity-30" />
              <p class="text-xs text-muted-foreground mt-1">Hardware sensor not available</p>
            {/if}
          </div>
        </div>
        <div class="flex flex-col gap-2">
            <Button size="icon" variant="outline" on:click={() => temperatureUnit = temperatureUnit === 'C' ? 'F' : 'C'}>
                {temperatureUnit === 'C' ? '°F' : '°C'}
            </Button>
            <div class="p-2 {temperatureLoading ? 'bg-blue-500/20' : hasRealTemperature ? (temperature > 80 ? 'bg-red-500/20' : temperature > 70 ? 'bg-orange-500/20' : temperature > 60 ? 'bg-yellow-500/20' : 'bg-green-500/20') : 'bg-gray-500/20'} rounded-lg">
                <Thermometer class="h-5 w-5 {temperatureLoading ? 'text-blue-500 animate-pulse' : hasRealTemperature ? (temperature > 80 ? 'text-red-500' : temperature > 70 ? 'text-orange-500' : temperature > 60 ? 'text-yellow-500' : 'text-green-500') : 'text-gray-500'}" />
            </div>
        </div>
      </div>
    </Card>
    
    <!-- Pool Status Card (only show when pool is selected) -->
    {#if $miningState.selectedPool !== 'solo'}
      <Card class="p-4">
        <div class="flex items-center justify-between">
          <div>
            <p class="text-sm text-muted-foreground">Pool Status</p>
            <p class="text-2xl font-bold">{poolConnected ? 'Connected' : 'Disconnected'}</p>
            <p class="text-xs text-muted-foreground mt-1">
              {poolConnected ? `${poolStats.connectedMiners} miners` : 'Not connected to pool'}
            </p>
          </div>
          <div class="p-2 {poolConnected ? 'bg-green-500/10' : 'bg-red-500/10'} rounded-lg">
            <div class="w-3 h-3 rounded-full {poolConnected ? 'bg-green-500' : 'bg-red-500'}"></div>
          </div>
        </div>
      </Card>
    {/if}
  </div>
  
  <!-- Mining Control -->
  <Card class="p-6">
    <div class="flex items-center justify-between mb-4">
      <h2 class="text-lg font-semibold">{$t('mining.control')}</h2>
      <Badge variant={$miningState.isMining ? 'default' : 'secondary'}>
        {$miningState.isMining ? $t('mining.active') : $t('mining.stopped')}
      </Badge>
    </div>
    
    <div class="space-y-4">
      <!-- Decentralized Pool Mining Section -->
      <div class="col-span-full">
        <div class="bg-muted/30 rounded-lg p-4 space-y-4">
          <div class="flex items-center justify-between">
            <h3 class="text-lg font-semibold">{$t('mining.decentralizedPools')}</h3>
            <div class="flex gap-2">
              <Button variant="outline" size="sm" on:click={discoverPoolsEnhanced} disabled={isDiscovering || $miningState.isMining}>
                {#if isDiscovering}
                  <RefreshCw class="h-4 w-4 mr-2 animate-spin" />
                  {$t('mining.discovering')}
                {:else}
                  <RefreshCw class="h-4 w-4 mr-2" />
                  {$t('mining.discoverPools')} (DHT)
                {/if}
              </Button>
              <Button variant="outline" size="sm" on:click={() => p2pDiscoverPools()} disabled={isDiscovering || $miningState.isMining}>
                <Network class="h-4 w-4 mr-2" />
                P2P Pools
              </Button>
              <Button variant="secondary" size="sm" on:click={() => showCreatePool = true} disabled={$miningState.isMining}>
                <Coins class="h-4 w-4 mr-2" />
                {$t('mining.createPool')}
              </Button>
            </div>
          </div>

          {#if currentPool}
            <!-- Currently Connected Pool -->
            <div class="bg-green-500/10 border border-green-500/20 rounded-lg p-4">
              <div class="flex items-center justify-between mb-3">
                <div class="flex items-center gap-2">
                  <div class="w-3 h-3 bg-green-500 rounded-full"></div>
                  <h4 class="font-semibold text-green-700">{$t('mining.poolDetails.connectedTo')}: {currentPool.pool.name}</h4>
                </div>
                <Button variant="destructive" size="sm" on:click={leavePool} disabled={$miningState.isMining}>
                  {$t('mining.poolDetails.leave')}
                </Button>
              </div>

              <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                <div>
                  <p class="text-muted-foreground">{$t('mining.poolDetails.yourHashrate')}</p>
                  <p class="font-semibold">{currentPool.stats.your_hashrate}</p>
                </div>
                <div>
                  <p class="text-muted-foreground">{$t('mining.poolDetails.poolHashrate')}</p>
                  <p class="font-semibold">{currentPool.stats.pool_hashrate}</p>
                </div>
                <div>
                  <p class="text-muted-foreground">{$t('mining.poolDetails.yourShare')}</p>
                  <p class="font-semibold">{currentPool.stats.your_share_percentage.toFixed(2)}%</p>
                </div>
                <div>
                  <p class="text-muted-foreground">{$t('mining.poolDetails.est24hPayout')}</p>
                  <p class="font-semibold">{currentPool.stats.estimated_payout_24h.toFixed(3)} Chiral</p>
                </div>
                <div>
                  <p class="text-muted-foreground">{$t('mining.poolDetails.shares')}</p>
                  <p class="font-semibold">{currentPool.stats.shares_accepted}/{currentPool.stats.shares_submitted}</p>
                </div>
                <div>
                  <p class="text-muted-foreground">{$t('mining.poolDetails.connectedMiners')}</p>
                  <p class="font-semibold">{currentPool.stats.connected_miners}</p>
                </div>
                <div>
                  <p class="text-muted-foreground">{$t('mining.poolDetails.poolFee')}</p>
                  <p class="font-semibold">{currentPool.pool.fee_percentage}%</p>
                </div>
                <div>
                  <p class="text-muted-foreground">{$t('mining.poolDetails.lastShare')}</p>
                  <p class="font-semibold">{formatTimestamp(currentPool.stats.last_share_time)}</p>
                </div>
              </div>
            </div>
          {:else}
            <!-- Solo Mining Status -->
            <div class="bg-blue-500/10 border border-blue-500/20 rounded-lg p-4">
              <div class="flex items-center gap-2">
                <div class="w-3 h-3 bg-blue-500 rounded-full"></div>
                <h4 class="font-semibold text-blue-700">{$t('mining.poolDetails.soloMining')}</h4>
              </div>
              <p class="text-sm text-muted-foreground mt-2">
                {$t('mining.poolDetails.soloMiningDesc')}
              </p>
            </div>
          {/if}

          {#if poolError}
            <div class="bg-red-500/10 border border-red-500/20 rounded-lg p-3">
              <p class="text-sm text-red-600">{poolError}</p>
            </div>
          {/if}
        </div>
      </div>

      <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
        
        <div>
          <Label for="thread-count">{$t('mining.cpuThreads', { values: { cpuThreads } })}</Label>
          <Input
                  id="thread-count"
                  type="number"
                  bind:value={selectedThreads}
                  on:input={(e: Event) => {
                      const target = e.currentTarget as HTMLInputElement;
                      selectedThreads = Number(target.value);
                    }}
                  min="1"
                  max={cpuThreads}
                  disabled={$miningState.isMining}
                  class="mt-2"
          />
          {#if threadsWarning}
            <p class="text-xs text-red-500 mt-1">{threadsWarning}</p>

          {/if}
        </div>
        
        <div>
          <Label for="intensity">{$t('mining.intensity')}</Label>
          <Input
                  id="intensity"
                  type="number"
                  bind:value={$miningState.minerIntensity}
                  on:input={(e: Event) => {
                      const target = e.currentTarget as HTMLInputElement;
                      $miningState.minerIntensity = Number(target.value);
                    }}
                  min="1"
                  max="100"
                  step="1"
                  disabled={$miningState.isMining}
                  class="mt-2"
          />

          {#if intensityWarning}
            <p class="text-xs text-red-500 mt-1">{intensityWarning}</p>

          {/if}
        </div>
      </div>
      
      <div class="flex items-center justify-between pt-4">
        <div class="text-sm space-y-1">
          <p class="text-muted-foreground">
            {$t('mining.session')}: <span class="font-medium">{$miningState.isMining ? formatUptime(uptimeNow) : '0h 0m 0s'}</span>
          </p>
          <p class="text-muted-foreground">
            {$t('mining.totalHashes')}: <span class="font-medium">{formatNumber(totalHashes)}</span>
          </p>
        </div>
        
        <div class="flex gap-2">
          <Button
            size="lg"
            on:click={() => $miningState.isMining ? stopMining() : startMining()}
            class="min-w-[150px]"
            disabled={isInvalid || !isGethRunning}
          >
            {#if $miningState.isMining}
              <Pause class="h-4 w-4 mr-2" />
              {$t('mining.stop')}
            {:else}
              <Play class="h-4 w-4 mr-2" />
              {$t('mining.start')}
            {/if}
          </Button>
          <Button
            size="lg"
            variant="outline"
            on:click={toggleLogs}
            title={$t('mining.showLogs')}
          >
            <Terminal class="h-4 w-4" />
          </Button>
        </div>
      </div>
      {#if validationError}
        <p class="text-red-600 text-sm mt-2 text-right">{validationError}</p>
      {/if}
      {#if error}
        <div class="bg-red-500/10 border border-red-500/20 rounded-lg p-3 mt-2">
          <div class="flex items-center gap-2">
            <AlertCircle class="h-4 w-4 text-red-500 flex-shrink-0" />
            <p class="text-sm text-red-500">{error}</p>
          </div>
        </div>
      {/if}
      {#if !isGethRunning}
        <div class="bg-yellow-500/10 border border-yellow-500/20 rounded-lg p-3 mt-2">
          <div class="flex items-center gap-2">
            <AlertCircle class="h-4 w-4 text-yellow-500 flex-shrink-0" />
            <p class="text-sm text-yellow-600">
              {$t('mining.errors.gethNotRunning')} <button on:click={() => { navigation.setCurrentPage('network'); goto('/network'); }} class="underline font-medium">{$t('mining.networkPage')}</button>
            </p>
          </div>
        </div>
      {/if}
      {#if !$etcAccount && isGethRunning}
        <div class="bg-blue-500/10 border border-blue-500/20 rounded-lg p-3 mt-2">
          <div class="flex items-center gap-2">
            <AlertCircle class="h-4 w-4 text-blue-500 flex-shrink-0" />
                        <p class="text-sm text-blue-600">
                          {@html $t('mining.errors.noAccountToStart', { values: { link: '<a href="/account" class="underline font-medium">' + $t('mining.accountPage') + '</a>' } })}
                        </p>
          </div>
        </div>
      {/if}
    </div>
  </Card>
  
  <!-- Mining Statistics -->
  <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
    <Card class="p-6">
      <h2 class="text-lg font-semibold mb-4">{$t('mining.networkStats')}</h2>
      <div class="space-y-3">
        <div class="flex justify-between items-center">
          <span class="text-sm text-muted-foreground">{$t('mining.networkHashRate')}</span>
          <Badge variant="outline">{networkHashRate}</Badge>
        </div>
        <div class="flex justify-between items-center">
          <span class="text-sm text-muted-foreground">{$t('mining.networkDifficulty')}</span>
          <Badge variant="outline">{networkDifficulty}</Badge>
        </div>
        <div class="flex justify-between items-center">
          <span class="text-sm text-muted-foreground">{$t('mining.blockHeight')}</span>
          <Badge variant="outline">#{currentBlock}</Badge>
        </div>
        <div class="flex justify-between items-center">
          <span class="text-sm text-muted-foreground">{$t('mining.blockReward')}</span>
          <Badge variant="outline">{blockReward} Chiral</Badge>
        </div>
        <div class="flex justify-between items-center">
          <span class="text-sm text-muted-foreground">{$t('mining.estTimeToBlock')}</span>
          <Badge variant="outline">
            {estimatedTimeToBlock > 0 ?
              `~${formatTimeFromSeconds(estimatedTimeToBlock)}` : $t('mining.calculating')}
          </Badge>
        </div>
        <div class="flex justify-between items-center">
          <span class="text-sm text-muted-foreground">{$t('mining.activeMiners')}</span>
          <Badge variant="outline">{peerCount}</Badge>
        </div>
      </div>
    </Card>
    
    <Card class="p-6">
      <h2 class="text-lg font-semibold mb-4">{$t('mining.poolInfo')}</h2>
      {#if $miningState.selectedPool === 'solo'}
        <div class="space-y-3">
          <p class="text-sm text-muted-foreground">
            {$t('mining.soloInfo')}
          </p>
          <div class="pt-2 space-y-2">
            <div class="flex justify-between">
              <span class="text-sm">{$t('mining.yourShare')}</span>
              <span class="text-sm font-medium">100%</span>
            </div>
            <div class="flex justify-between">
              <span class="text-sm">{$t('mining.poolFee')}</span>
              <span class="text-sm font-medium">0%</span>
            </div>
            <div class="flex justify-between">
              <span class="text-sm">{$t('mining.minPayout')}</span>
              <span class="text-sm font-medium">{$t('mining.na')}</span>
            </div>
          </div>
        </div>
      {:else}
        <div class="space-y-3">
          <div class="flex justify-between">
            <span class="text-sm">{$t('mining.poolHashRate')}</span>
            <span class="text-sm font-medium">850 MH/s</span>
          </div>
          <div class="flex justify-between">
            <span class="text-sm">{$t('mining.poolMiners')}</span>
            <span class="text-sm font-medium">342</span>
          </div>
          <div class="flex justify-between">
            <span class="text-sm">{$t('mining.yourShare')}</span>
            <span class="text-sm font-medium">{(parseHashRate($miningState.hashRate) / 850000000 * 100).toFixed(4)}%</span>
          </div>
          <div class="flex justify-between">
            <span class="text-sm">{$t('mining.poolFee')}</span>
            <span class="text-sm font-medium">1%</span>
          </div>
          <div class="flex justify-between">
            <span class="text-sm">{$t('mining.minPayout')}</span>
            <span class="text-sm font-medium">10 Chiral</span>
          </div>
          <div class="flex justify-between">
            <span class="text-sm">{$t('mining.paymentMethod')}</span>
            <span class="text-sm font-medium">PPLNS</span>
          </div>
        </div>
      {/if}
    </Card>
  </div>
  
  <!-- Recent Blocks -->
  <Card class="p-6">
    <h2 class="text-lg font-semibold mb-4">{$t('mining.recentBlocks')}</h2>
    {#if (!$miningState.recentBlocks || $miningState.recentBlocks.length === 0)}
      <p class="text-sm text-muted-foreground text-center py-8">
        {$t('mining.noBlocksFound')}
      </p>
    {:else}
      <div class="space-y-2">
        <div class="flex items-center justify-between mb-2">
          <div class="flex items-center gap-2">
            <label for="page-size-select" class="text-sm text-muted-foreground">{$t('Page Size')}:</label>
            <select id="page-size-select" bind:value={pageSize} on:change={() => { currentPage = 1 }} class="px-2 py-1 rounded border bg-background text-sm">
              {#each pageSizes as s}
                <option value={s}>{s}</option>
              {/each}
            </select>
          </div>

          <div class="flex items-center gap-2">
            <button class="px-2 py-1 rounded border bg-background text-sm" on:click={() => { if (currentPage > 1) currentPage -= 1 }} disabled={currentPage <= 1}>
              {$t('prev')}
            </button>
            <div class="text-sm text-muted-foreground">{currentPage} / {totalPages}</div>
            <button class="px-2 py-1 rounded border bg-background text-sm" on:click={() => { if (currentPage < totalPages) currentPage += 1 }} disabled={currentPage >= totalPages}>
              {$t('next')}
            </button>
          </div>
        </div>

        <div class="space-y-2 max-h-80 overflow-y-auto pr-1">
          {#each displayedBlocks ?? [] as block}
            <div class="flex items-center justify-between p-3 bg-secondary rounded-lg">
              <div class="flex items-center gap-3">
                <Award class="h-4 w-4 text-yellow-500" />
                <div>
                  <p class="text-sm font-medium">{$t('mining.blockFound')}</p>
                  <p class="text-xs text-muted-foreground">
                    {$t('mining.hash')}: {block.hash} • {$t('mining.nonce')}: {block.nonce}
                  </p>
                </div>
              </div>
              <div class="text-right">
                <Badge variant="outline" class="text-green-600">
                  +{block.reward.toFixed(2)} Chiral
                </Badge>
                <p class="text-xs text-muted-foreground mt-1">
                  {block.timestamp.toLocaleTimeString()}
                </p>
              </div>
            </div>
          {/each}
        </div>
      </div>
    {/if}
  </Card>
  
  <!-- Hash Rate Chart (simplified) -->
  {#if ($miningState.miningHistory || []).length > 0}
    <Card class="p-6">
      <h2 class="text-lg font-semibold mb-4">{$t('mining.hashRateHistory')}</h2>

      <!-- Chart Type Toggle -->
      <div class="flex items-center gap-2 mb-2">
        <span class="text-sm text-muted-foreground">{$t('mining.chartType')}:</span>
        <Button size="sm" variant={chartType === 'bar' ? 'default' : 'outline'} on:click={() => chartType = 'bar'}>{$t('mining.bar')}</Button>
        <Button size="sm" variant={chartType === 'line' ? 'default' : 'outline'} on:click={() => chartType = 'line'}>{$t('mining.line')}</Button>
      </div>

      <!-- Chart with Y-axis, gradients, tooltips, and axis labels -->
      <div class="flex h-48 gap-2">
        <!-- Y-axis labels -->
        <div class="flex flex-col justify-between text-xs text-muted-foreground pr-2">
          <span>{Math.max(...($miningState.miningHistory || []).map(h => h.hashRate)).toFixed(0)} H/s</span>
          <span>{(Math.max(...($miningState.miningHistory || []).map(h => h.hashRate)) / 2).toFixed(0)} H/s</span>
          <span>0</span>
        </div>

        <div class="relative flex-1">
          <!-- Gridlines -->
          <div class="absolute inset-0 flex flex-col justify-between">
            <div class="border-t border-muted-foreground/20"></div>
            <div class="border-t border-muted-foreground/20"></div>
            <div class="border-t border-muted-foreground/20"></div>
          </div>

          {#if chartType === 'bar'}
            <!-- Bar Chart -->
            <div class="flex items-end gap-1 h-full">
              {#each ($miningState.miningHistory || []) as point, i}
                <div
                  role="button"
                  tabindex="0"
                  class="flex-1 bg-gradient-to-t from-blue-400/40 to-blue-500/80 hover:from-blue-500/60 hover:to-blue-600/90 transition-all rounded-t-md shadow-sm relative group"
                  style="height: {(point.hashRate / Math.max(...($miningState.miningHistory || []).map(h => h.hashRate))) * 100}%"
                  title="{formatHashRate(point.hashRate)}"
                  on:mouseenter={() => { hoveredPoint = point; hoveredIndex = i; }}
                  on:mouseleave={() => { hoveredPoint = null; hoveredIndex = null; }}
                  aria-label={formatHashRate(point.hashRate) + ' at ' + new Date(point.timestamp).toLocaleTimeString()}
                >
                  {#if hoveredIndex === i && hoveredPoint}
                    <div
                      class="absolute left-1/2 -translate-x-1/2 -top-8 z-10 px-2 py-1 rounded bg-primary text-white text-xs shadow-lg pointer-events-none"
                      style="white-space:nowrap;"
                    >
                      {formatHashRate(hoveredPoint.hashRate)}<br/>{new Date(hoveredPoint.timestamp).toLocaleTimeString()}
                      <span class="absolute left-1/2 -translate-x-1/2 top-full w-0 h-0 border-l-6 border-l-transparent border-r-6 border-r-transparent border-t-6 border-t-primary"></span>
                    </div>
                  {/if}
                </div>
              {/each}
            </div>
          {:else}
            <!-- Line Chart -->
            <div class="relative h-full">
              <svg class="w-full h-full" viewBox="0 0 100 100" preserveAspectRatio="none">
                <!-- Line -->
                <polyline
                  fill="none"
                  stroke="rgb(59, 130, 246)"
                  stroke-width="1.5"
                  stroke-linecap="round"
                  stroke-linejoin="round"
                  points={($miningState.miningHistory || []).map((point, i) => {
                    const x = (i / Math.max(($miningState.miningHistory || []).length - 1, 1)) * 100;
                    const maxHash = Math.max(...($miningState.miningHistory || []).map(h => h.hashRate)) || 1;
                    const y = 100 - ((point.hashRate / maxHash) * 100);
                    return `${x},${y}`;
                  }).join(' ')}
                  class="drop-shadow-sm"
                />
                <!-- Area under the line -->
                <polygon
                  fill="url(#miningGradient)"
                  opacity="0.3"
                  points={($miningState.miningHistory || []).map((point, i) => {
                    const x = (i / Math.max(($miningState.miningHistory || []).length - 1, 1)) * 100;
                    const maxHash = Math.max(...($miningState.miningHistory || []).map(h => h.hashRate)) || 1;
                    const y = 100 - ((point.hashRate / maxHash) * 100);
                    return `${x},${y}`;
                  }).join(' ') + ` 100,100 0,100`}
                />
                <!-- Data points -->
                {#each ($miningState.miningHistory || []) as point, i}
                  <circle
                    cx={i / Math.max(($miningState.miningHistory || []).length - 1, 1) * 100}
                    cy={100 - ((point.hashRate / Math.max(...($miningState.miningHistory || []).map(h => h.hashRate)) || 1) * 100)}
                    r="1.2"
                    fill="rgb(59, 130, 246)"
                    stroke="white"
                    stroke-width="0.2"
                    class="cursor-pointer hover:r-2 transition-all"
                    role="button"
                    tabindex="0"
                    aria-label={formatHashRate(point.hashRate) + ' at ' + new Date(point.timestamp).toLocaleTimeString()}
                    on:mouseenter={() => { hoveredPoint = point; hoveredIndex = i; }}
                    on:mouseleave={() => { hoveredPoint = null; hoveredIndex = null; }}
                  />
                {/each}
                <!-- Gradient definition -->
                <defs>
                  <linearGradient id="miningGradient" x1="0%" y1="0%" x2="0%" y2="100%">
                    <stop offset="0%" style="stop-color:rgb(59, 130, 246);stop-opacity:0.4" />
                    <stop offset="100%" style="stop-color:rgb(59, 130, 246);stop-opacity:0.05" />
                  </linearGradient>
                </defs>
              </svg>

              <!-- Tooltip for line chart -->
              {#if hoveredPoint && hoveredIndex !== null}
                <div
                  class="absolute z-10 px-2 py-1 rounded bg-primary text-white text-xs shadow-lg pointer-events-none"
                  style="
                    left: {(hoveredIndex / Math.max(($miningState.miningHistory || []).length - 1, 1)) * 100}%;
                    top: {100 - ((hoveredPoint.hashRate / Math.max(...($miningState.miningHistory || []).map(h => h.hashRate)) || 1) * 100)}%;
                    transform: translate(-50%, -100%);
                    margin-top: -8px;
                    white-space: nowrap;"
                >
                  {formatHashRate(hoveredPoint.hashRate)}<br/>{new Date(hoveredPoint.timestamp).toLocaleTimeString()}
                  <span class="absolute left-1/2 -translate-x-1/2 top-full w-0 h-0 border-l-6 border-l-transparent border-r-6 border-r-transparent border-t-6 border-t-primary"></span>
                </div>
              {/if}
            </div>
          {/if}
        </div>
      </div>
      <!-- X-axis labels -->
      <div class="flex justify-between mt-2 text-xs text-muted-foreground">
        <span>{($miningState.miningHistory || [])[0] ? new Date(($miningState.miningHistory || [])[0].timestamp).toLocaleTimeString() : ''}</span>
        <span>{($miningState.miningHistory || [])[($miningState.miningHistory || []).length - 1] ? new Date(($miningState.miningHistory || [])[($miningState.miningHistory || []).length - 1].timestamp).toLocaleTimeString() : ''}</span>
      </div>
      <p class="text-xs text-muted-foreground text-center mt-2">{$t('mining.last5Minutes')}</p>
    </Card>
  {/if}
  </div>

  <!-- Logs Modal -->
  {#if showLogs}
    <div class="fixed inset-0 bg-background/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
      <Card class="w-full max-w-4xl max-h-[80vh] flex flex-col">
        <div class="p-4 border-b flex items-center justify-between">
          <h2 class="text-lg font-semibold">{$t('mining.logs')}</h2>
          <Button size="sm" variant="ghost" on:click={toggleLogs}>
            <X class="h-4 w-4" />
          </Button>
        </div>
        <div class="flex-1 p-4">
          {#if filteredLogs.length === 0}
            <p class="text-xs text-muted-foreground">{$t('mining.noLogs')}</p>
            {:else}
            <div class="bg-secondary/50 rounded-lg p-2 max-h-[60vh] overflow-y-auto text-left font-mono text-xs">
              <!-- When wrapping is disabled, allow horizontal scroll and preserve whitespace -->
              <div class={wrapLogs ? 'w-full' : 'w-full overflow-x-auto'}>
                {#each filteredLogs.slice(-500) as log}
                  {@const split = splitLogPrefix(log)}
                  <p class="font-mono {wrapLogs ? 'whitespace-pre-wrap break-words' : 'whitespace-pre'}">
                    {#if split.prefix}
                      <span class={logLevelClass(split.prefix)}>{split.prefix}</span>
                      <span class="text-muted-foreground"> {split.rest}</span>
                    {:else}
                      <span class="text-muted-foreground">{split.rest}</span>
                    {/if}
                  </p>
                {/each}
              </div>
            </div>
          {/if}
        </div>

        <div class="p-4 border-t flex items-center justify-between">
          <div class="flex items-center gap-3">
            <input id="auto-refresh" type="checkbox" bind:checked={autoRefresh} on:change={() => {
              // If modal is open, start/stop the interval immediately
              if (showLogs) {
                if (autoRefresh && !logsInterval) {
                  logsInterval = setInterval(fetchLogs, 2000) as unknown as number
                } else if (!autoRefresh && logsInterval) {
                  clearInterval(logsInterval)
                  logsInterval = null
                }
              }
            }} />
            <label for="auto-refresh" class="text-sm text-muted-foreground">{$t('mining.autoRefresh')}</label>
            
            <!-- Wrap toggle -->
            <div class="flex items-center gap-2 ml-3">
              <input id="wrap-logs" type="checkbox" bind:checked={wrapLogs} />
              <label for="wrap-logs" class="text-sm text-muted-foreground">{$t('mining.wrapLogs')}</label>
            </div>
          </div>

          <!-- Log Level Filters -->
          <div class="flex items-center gap-2">
            <span class="text-sm text-muted-foreground">{$t('mining.filterByLevel')}:</span>
            <div class="flex gap-1">
              {#each Object.entries(logFilters) as [level, enabled]}
                <button
                  class="px-2 py-1 text-xs rounded {enabled ? 'bg-primary text-primary-foreground' : 'bg-secondary text-secondary-foreground'}"
                  on:click={() => logFilters[level] = !enabled}
                >
                  {level.toUpperCase()}
                </button>
              {/each}
            </div>
          </div>

          <div class="flex items-center gap-2">
            <Button size="sm" variant="outline" on:click={fetchLogs}>
              <RefreshCw class="h-3 w-3 mr-1" />
              {$t('mining.refresh')}
            </Button>
            <Button size="sm" variant="outline" on:click={() => logs = []}>
              {$t('mining.clear')}
            </Button>
          </div>
        </div>
      </Card>
    </div>
  {/if}

  <!-- Pool Management Modal -->
  {#if showPoolManager}
    <div class="fixed inset-0 bg-black/50 flex items-center justify-center z-50">
      <div class="bg-background rounded-lg p-6 w-full max-w-2xl mx-4 max-h-[80vh] overflow-y-auto">
        <div class="flex items-center justify-between mb-4">
          <h2 class="text-xl font-semibold">
            {editingPool ? 'Edit Pool' : 'Manage Pools'}
          </h2>
          <Button variant="ghost" size="sm" on:click={cancelPoolEdit}>
            <X class="h-4 w-4" />
          </Button>
        </div>

        <!-- Pool List -->
        <div class="space-y-3 mb-6">
          <h3 class="font-medium">Existing Pools</h3>
          {#each pools as pool (pool.id)}
            <div class="flex items-center justify-between p-3 border rounded-lg">
              <div class="flex-1">
                <div class="font-medium">{pool.name}</div>
                <div class="text-sm text-muted-foreground">
                  {pool.url || 'Solo Mining'}
                </div>
              </div>
              <div class="flex gap-2">
                {#if pool.id !== 'solo'}
                  <Button
                    variant="outline"
                    size="sm"
                    on:click={() => editPool(pool)}
                  >
                    Edit
                  </Button>
                  <Button
                    variant="destructive"
                    size="sm"
                    on:click={() => deletePool(pool.id)}
                  >
                    Delete
                  </Button>
                {/if}
              </div>
            </div>
          {/each}
        </div>

        <!-- Add/Edit Pool Form -->
        <div class="space-y-4">
          <h3 class="font-medium">
            {editingPool ? 'Edit Pool' : 'Add New Pool'}
          </h3>
          
          <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div>
              <Label for="pool-name">Pool Name</Label>
              <Input
                id="pool-name"
                value={editingPool ? editingPool.name : newPool.name}
                on:input={(e: Event) => {
                  const target = e.target as HTMLInputElement
                  if (editingPool) {
                    editingPool.name = target.value
                  } else {
                    newPool.name = target.value
                  }
                }}
                placeholder="My Mining Pool"
                class="mt-2"
              />
            </div>
            <div>
              <Label for="pool-url">Pool URL</Label>
              <Input
                id="pool-url"
                value={editingPool ? editingPool.url : newPool.url}
                on:input={(e: Event) => {
                  const target = e.target as HTMLInputElement
                  if (editingPool) {
                    editingPool.url = target.value
                  } else {
                    newPool.url = target.value
                  }
                }}
                placeholder="stratum://pool.example.com:3333"
                class="mt-2"
              />
            </div>
            <div>
              <Label for="pool-worker">Worker Name</Label>
              <Input
                id="pool-worker"
                value={editingPool ? (editingPool.worker ?? '') : newPool.worker}
                on:input={(e: Event) => {
                  const target = e.target as HTMLInputElement
                  if (editingPool) {
                    editingPool.worker = target.value
                  } else {
                    newPool.worker = target.value
                  }
                }}
                placeholder="worker1"
                class="mt-2"
              />
            </div>
            <div>
              <Label for="pool-password">Password</Label>
              <Input
                id="pool-password"
                value={editingPool ? (editingPool.password ?? '') : newPool.password}
                on:input={(e: Event) => {
                  const target = e.target as HTMLInputElement
                  if (editingPool) {
                    editingPool.password = target.value
                  } else {
                    newPool.password = target.value
                  }
                }}
                placeholder="x"
                class="mt-2"
              />
            </div>
          </div>

          <div class="flex gap-2 pt-4">
            {#if editingPool}
              <Button on:click={savePool}>
                Save Changes
              </Button>
            {:else}
              <Button on:click={addPool}>
                Add Pool
              </Button>
            {/if}
            <Button variant="outline" on:click={cancelPoolEdit}>
              Cancel
            </Button>
          </div>
        </div>
      </div>
    </div>
  {/if}

  <!-- Old pool UI removed - using new decentralized system -->


<!-- Pool Discovery Modal -->
{#if showPoolList}
  <div class="fixed inset-0 bg-background/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
    <Card class="w-full max-w-4xl max-h-[80vh] flex flex-col">
      <div class="p-4 border-b flex items-center justify-between">
        <h2 class="text-lg font-semibold">{$t('mining.poolDetails.availablePools')}</h2>
        <Button size="sm" variant="ghost" on:click={() => showPoolList = false}>
          <X class="h-4 w-4" />
        </Button>
      </div>

      <div class="flex-1 overflow-y-auto p-4">
        {#if availablePools.length === 0}
          <div class="text-center py-8">
            <p class="text-muted-foreground">{$t('mining.poolDetails.noPoolsFound')}</p>
          </div>
        {:else}
          <div class="space-y-3">
            {#each availablePools as pool}
              <div class="border rounded-lg p-4 hover:bg-muted/50">
                <div class="flex items-start justify-between">
                  <div class="flex-1">
                    <div class="flex items-center gap-2 mb-2">
                      <h3 class="font-semibold">{pool.name}</h3>
                      <Badge variant="outline" class={getPoolStatusColor(pool.status)}>
                        {pool.status}
                      </Badge>
                      <Badge variant="secondary">{pool.region}</Badge>
                      {#if pool.discovered_via_p2p}
                        <Badge variant="default" class="bg-purple-500">
                          <Network class="h-3 w-3 mr-1" />
                          P2P
                        </Badge>
                      {/if}
                    </div>
                    
                    <p class="text-sm text-muted-foreground mb-3">{pool.description}</p>
                    
                    <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                      <div>
                        <p class="text-muted-foreground">{$t('mining.poolDetails.miners')}</p>
                        <p class="font-medium">{pool.miners_count}</p>
                      </div>
                      <div>
                        <p class="text-muted-foreground">{$t('mining.poolDetails.hashrate')}</p>
                        <p class="font-medium">{pool.total_hashrate}</p>
                      </div>
                      <div>
                        <p class="text-muted-foreground">{$t('mining.poolDetails.fee')}</p>
                        <p class="font-medium">{pool.fee_percentage}%</p>
                      </div>
                      <div>
                        <p class="text-muted-foreground">{$t('mining.poolDetails.lastBlock')}</p>
                        <p class="font-medium">{pool.last_block_time > 0 ? formatTimestamp(pool.last_block_time) : $t('mining.poolDetails.never')}</p>
                      </div>
                      <div>
                        <p class="text-muted-foreground">{$t('mining.poolDetails.blocks24h')}</p>
                        <p class="font-medium">{pool.blocks_found_24h}</p>
                      </div>
                      <div>
                        <p class="text-muted-foreground">{$t('mining.poolDetails.minPayout')}</p>
                        <p class="font-medium">{pool.min_payout} Chiral</p>
                      </div>
                      <div>
                        <p class="text-muted-foreground">{$t('mining.poolDetails.payment')}</p>
                        <p class="font-medium">{pool.payment_method}</p>
                      </div>
                      <div>
                        <p class="text-muted-foreground">{$t('mining.poolDetails.url')}</p>
                        <p class="font-mono text-xs">{pool.url}</p>
                      </div>
                    </div>
                  </div>

                  <div class="ml-4">
                    <Button
                      size="sm"
                      on:click={() => joinPool(pool)}
                      disabled={pool.status !== 'Active' || $miningState.isMining}
                    >
                      {$t('mining.poolDetails.join')}
                    </Button>
                  </div>
                </div>
              </div>
            {/each}
          </div>
        {/if}
      </div>
    </Card>
  </div>
{/if}

<!-- Create Pool Modal -->
{#if showCreatePool}
  <div class="fixed inset-0 bg-background/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
    <Card class="w-full max-w-2xl">
      <div class="p-4 border-b flex items-center justify-between">
        <h2 class="text-lg font-semibold">{$t('mining.poolDetails.createNew')}</h2>
        <Button size="sm" variant="ghost" on:click={() => showCreatePool = false}>
          <X class="h-4 w-4" />
        </Button>
      </div>

      <div class="p-4 space-y-4">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <Label for="pool-name">{$t('mining.poolDetails.poolName')} *</Label>
            <Input
              id="pool-name"
              bind:value={newPool.name}
              placeholder={$t('mining.poolDetails.poolNamePlaceholder')}
              class="mt-2"
            />
          </div>
          <div>
            <Label for="pool-region">{$t('mining.poolDetails.region')}</Label>
            <select bind:value={newPool.region} class="w-full mt-2 px-3 py-2 border rounded-md bg-background">
              <option value="Global">Global</option>
              <option value="Americas">Americas</option>
              <option value="Europe">Europe</option>
              <option value="Asia">Asia</option>
              <option value="Oceania">Oceania</option>
            </select>
          </div>
        </div>
        
        <div>
          <Label for="pool-description">{$t('mining.poolDetails.description')}</Label>
          <Input
            id="pool-description"
            bind:value={newPool.description}
            placeholder={$t('mining.poolDetails.descriptionPlaceholder')}
            class="mt-2"
          />
        </div>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <div>
            <Label for="pool-fee">{$t('mining.poolDetails.feePercentage')}</Label>
            <Input
              id="pool-fee"
              type="number"
              bind:value={newPool.fee_percentage}
              min="0"
              max="10"
              step="0.1"
              class="mt-2"
            />
          </div>
          <div>
            <Label for="pool-payout">{$t('mining.poolDetails.minPayoutChiral')}</Label>
            <Input
              id="pool-payout"
              type="number"
              bind:value={newPool.min_payout}
              min="0.1"
              step="0.1"
              class="mt-2"
            />
          </div>
          <div>
            <Label for="pool-payment">{$t('mining.poolDetails.paymentMethod')}</Label>
            <select bind:value={newPool.payment_method} class="w-full mt-2 px-3 py-2 border rounded-md bg-background">
              <option value="PPLNS">PPLNS</option>
              <option value="PPS">PPS</option>
              <option value="PPS+">PPS+</option>
              <option value="PROP">PROP</option>
            </select>
          </div>
        </div>
        
        <div class="bg-blue-500/10 border border-blue-500/20 rounded-lg p-3">
          <p class="text-sm text-blue-600">
            <strong>{$t('mining.poolDetails.note')}:</strong> {$t('mining.poolDetails.createNote')}
          </p>
        </div>

        <div class="flex justify-end gap-2 pt-4">
          <Button variant="outline" on:click={() => showCreatePool = false}>
            {$t('mining.poolDetails.cancel')}
          </Button>
          <Button on:click={createNewPool} disabled={!newPool.name.trim()}>
            {$t('mining.createPool')}
          </Button>
        </div>
      </div>
    </Card>
  </div>
{/if}
